<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Test jQluster.{Transport, RemoteSelector}</title>
<link rel="stylesheet" href="./qunit.css">
<style type="text/css">
#sized-box {
    background-color: red;
    width: 200px;
    height: 50px;
    padding: 5px;
    margin: 5px;
    border-width: 0;
}

#hidden-box {
    opacity: 0;
    display: none;
}

#visible-box {
    opacity: 1;
}

</style>
</head>
<body>
<div id="qunit"></div>
<div id="qunit-fixture"></div>
<script src="../static/js/jquery.js"></script>
<script src="../static/js/jquery.ellocate.js"></script>
<script src="../static/js/jquery.xpath.js"></script>
<script src="./qunit.js"></script>
<script src="../js/util.js"></script>
<script src="../js/connection.js"></script>
<script src="../js/local_server.js"></script>
<script src="../js/transport.js"></script>
<script src="../js/remote_selector.js"></script>
<script src="./test_utils.js"></script>
<script>
"use strict";

var server;
var alice;
var alice_connection;
var bob;
var bob_connection;

var createTransport = function(remote_id) {
    var conn = new jQluster.ConnectionLocal(server);
    var trans = new jQluster.Transport({
        remote_id: remote_id,
        connection_object: conn
    });
    return [conn, trans];
};

var setupAlice = function() {
    var ret = createTransport("alice");
    alice_connection = ret[0];
    alice = ret[1];
};

var setupBob = function() {
    var ret = createTransport("bob");
    bob_connection = ret[0];
    bob = ret[1];
};

var setupTest = function() {
    server = new jQluster.ServerLocal();
    $('#qunit-fixture').append(
        '<div id="test">'
            +   '<ul>'
            +     '<li>1</li>'
            +     '<li class="two">2</li>'
            +     '<li>3</li>'
            +   '</ul>'
            +   '<input id="test_button" type="button" value="Test Button" />'
            +   '<div id="sized-box">hoge</div>'
            +   '<div id="with-data" data-some-data="100"></div>'
            +   '<div id="hidden-box">hidden</div>'
            +   '<div id="visible-box">visible</div>'
            + '</div>'
    );
};

var setupAll = function() {
    setupTest();
    setupAlice();
    setupBob();
};

var teardownTest = function() {
    server = undefined;
    alice = undefined;
    alice_connection = undefined;
    bob = undefined;
    bob_connection = undefined;
};

var TIMEOUT_MSEC = 3000;

var setTimeLimit = function() {
    return setTimeout(function() {
        ok(false, "It tooks too long.");
        start();
    }, TIMEOUT_MSEC);
};

module("jQluster.Transport", {
    setup: setupTest,
    teardown: teardownTest,
});

test("registration", function() {
    setupAlice();
    setupBob();
    deepEqual(server.getRegisterLog(), ["alice", "bob"], "registration OK");
    $.each([
        {id: "alice", log: alice_connection.getLog()},
        {id: "bob",   log: bob_connection.getLog()}
    ], function(i, params) {
        var id = params.id;
        var log = params.log;
        is(log.length, 2, "2 communication logs");
        is(log[0].direction, "send", "log 0 : send");
        is(log[0].message.message_type, "register", "log 0 : register");
        is(log[0].message.from, id, "log 0 from");
        is(log[0].message.to, null, "log 0 to");
        deepEqual(log[0].message.body, {remote_id: id}, "log 0 body");
        
        is(log[1].direction, "receive", "log 1 : receive");
        is(log[1].message.message_type, "register_reply", "log 1 : register_reply");
        is(log[1].message.from, null, "log 1 from");
        is(log[1].message.to, id, "log 1 to");
        deepEqual(log[1].message.body, {error: null, in_reply_to: log[0].message.message_id}, "log 1 body");
    });
});

asyncTest("selectAndGet - single target", function() {
    setupAlice();
    setupBob();
    alice_connection.clearLog();
    bob_connection.clearLog();

    alice.selectAndGet({
        eval_code: "$(\"#test\").find(\".two\").text()",
        remote_id: "bob"
    }).then(function(data) {
        var alog = alice_connection.getLog();
        var blog = bob_connection.getLog();
        is(data, "2", "obtained data OK");
        is(alog.length, 2);
        is(blog.length, 2);
        is(alog[0].direction, "send");
        is(alog[0].message.message_type, "select_and_get");
        is(alog[0].message.from, "alice");
        is(alog[0].message.to, "bob");
        deepEqual(alog[0].message.body, {
            eval_code: "$(\"#test\").find(\".two\").text()",
            remote_id: "bob"
        });
        is(blog[0].direction, "receive");
        is(blog[0].message.message_type, "select_and_get");
        is(blog[0].message.from, "alice");
        is(blog[0].message.to, "bob");
        is(blog[0].message.message_id, alog[0].message.message_id);
        deepEqual(blog[0].message.body, {
            eval_code: "$(\"#test\").find(\".two\").text()",
            remote_id: "bob"
        });

        is(blog[1].direction, "send");
        is(blog[1].message.message_type, "select_and_get_reply");
        is(blog[1].message.from, "bob");
        is(blog[1].message.to, "alice");
        deepEqual(blog[1].message.body, { error: null, result: "2", in_reply_to: alog[0].message.message_id });
        is(alog[1].direction, "receive");
        is(alog[1].message.message_type, "select_and_get_reply");
        is(alog[1].message.from, "bob");
        is(alog[1].message.to, "alice");
        is(alog[1].message.message_id, blog[1].message.message_id);
        deepEqual(alog[1].message.body, { error: null, result: "2", in_reply_to: alog[0].message.message_id });
    }, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("selectAndGet - no target: the server should return an error message", function() {
    setupAlice();
    var promise_select = alice.selectAndGet({
        eval_code: "$('#test li').eq(2).text()",
        remote_id: "bob"
    });
    promise_select.then(function() {
        ok(false, "the returned promise should not be resolved.");
    }, function(error) {
        var alog = alice_connection.getLog();
        ok(jQluster.defined(error), "it should return some defined error.");
        is(alog.length, 4);
        is(alog[0].direction, "send");
        is(alog[0].message.message_type, "register");
        is(alog[1].direction, "receive");
        is(alog[1].message.message_type, "register_reply");
        is(alog[2].direction, "send");
        is(alog[2].message.message_type, "select_and_get");
        is(alog[2].message.from, "alice");
        is(alog[2].message.to, "bob");
        deepEqual(alog[2].message.body, {eval_code: "$('#test li').eq(2).text()", remote_id: "bob"});
        is(alog[3].direction, "receive");
        is(alog[3].message.message_type, "select_and_get_reply");
        is(alog[3].message.from, null);
        is(alog[3].message.to, "alice");
        is(alog[3].message.body.in_reply_to, alog[2].message.message_id);
        ok(jQluster.defined(alog[3].message.body.error));
    }).always(function() {
        start();
    });
});

asyncTest("selectAndGet - multiple targets: the result is returned from any one of the receivers.", function() {
    setupAlice();
    setupBob();
    var bob2_set = createTransport("bob");
    var bob2_connection = bob2_set[0];
    alice_connection.clearLog();
    bob_connection.clearLog();
    bob2_connection.clearLog();
    alice.selectAndGet({
        eval_code: "$('#test > ul').eq(0).children().eq(1).text()",
        remote_id: "bob"
    }).then(function(data) {
        var alog = alice_connection.getLog();
        var blog = bob_connection.getLog();
        var b2log = bob_connection.getLog();
        is(data, "2");
        ok(alog.length >= 2, "alog should include 1 send and at least 1 receive.");
        is(alog[0].direction, "send");
        is(alog[0].message.message_type, "select_and_get");
        is(alog[0].message.from, "alice");
        is(alog[0].message.to, "bob");
        deepEqual(alog[0].message.body, {eval_code: "$('#test > ul').eq(0).children().eq(1).text()", remote_id: "bob"});
        is(alog[1].direction, "receive");
        is(alog[1].message.message_type, "select_and_get_reply");
        is(alog[1].message.to, "alice");
        is(alog[1].message.from, "bob");
        deepEqual(alog[1].message.body, {error: null, result: "2", in_reply_to: alog[0].message.message_id});

        $.each([{label: "bob", log: blog}, {label: "bob2", log: b2log}], function(i, e) {
            ok(e.log.length >= 1, e.log.label + " should at least have 'receive' log from alice");
            is(e.log[0].direction, "receive", e.log.label + " [0] receive");
            is(e.log[0].message.message_type, "select_and_get", e.log.label + " [0] type = select_and_get");
            is(e.log[0].message.from, "alice", e.log.label + " [0] from = alice");
            is(e.log[0].message.to, "bob", e.log.label + " [0] to = bob");
            deepEqual(e.log[0].message.body, {eval_code: "$('#test > ul').eq(0).children().eq(1).text()", remote_id: "bob"}, e.log.label + " [0] body OK");
        });
    }, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("selectAndGet - get promise to wait animation", function() {
    setupAlice();
    setupBob();
    alice.selectAndGet({
        remote_id: "bob",
        eval_code: '$("#test").find("li").eq(1).fadeOut()'
    });
    is($("li.two").css("display"), "list-item", "the element is still visible");
    alice.selectAndGet({
        remote_id: "bob",
        eval_code: '$("li.two")',
    }).then(function() {
        is($("li.two").css("display"), "none", "the element is invisible now");
    }).then(null, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("selectAndListen - single target", function() {
    setupAlice();
    setupBob();
    alice_connection.clearLog();
    bob_connection.clearLog();
    var event_deferred = $.Deferred();
    alice.selectAndListen({
        remote_id: "bob",
        eval_code: "$('#test input#test_button')",
        method: "on",
        options: ["click"],
        callback: function(event) {
            if(event_deferred.state() !== "pending") {
                ok(false, "event callback called multiple times");
            }
            event_deferred.resolve(this, event);
        }
    }).then(function() {
        var alog = alice_connection.getLog();
        var blog = bob_connection.getLog();
        is(alog.length, 2);
        is(alog[0].direction, "send");
        is(alog[0].message.message_type, "select_and_listen");
        is(alog[0].message.from, "alice");
        is(alog[0].message.to, "bob");
        deepEqual(alog[0].message.body, {
            remote_id: "bob", eval_code: "$('#test input#test_button')",
            method: "on",
            options: ["click"]
        });
        is(alog[1].direction, "receive");
        is(alog[1].message.message_type, "select_and_listen_reply");
        is(alog[1].message.from, "bob");
        is(alog[1].message.to, "alice");
        is(alog[1].message.body.error, null);
        is(alog[1].message.body.in_reply_to, alog[0].message.message_id);
        
        is(blog.length, 2);
        is(blog[0].direction, "receive");
        deepEqual(blog[0].message, alog[0].message);
        is(blog[1].direction, "send");
        deepEqual(blog[1].message, alog[1].message);

        is(event_deferred.state(), "pending");
        $('#test_button').trigger('click');
        return event_deferred.promise();
    }).then(function(event_this, event) {
        var alog = alice_connection.getLog();
        var blog = bob_connection.getLog();
        deepEqual(event_this, {
            remote_type: "xpath", remote_id: "bob",
            remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
        });
        ok(jQluster.defined(event));
        // console.log("delivered event in selectAndListen (single target):");
        // console.log(event);
        is(alog.length, 3);
        is(alog[2].direction, "receive");
        is(alog[2].message.message_type, "signal");
        is(alog[2].message.from, "bob");
        is(alog[2].message.to, "alice");
        deepEqual(alog[2].message.body, {
            error: null, in_reply_to: alog[0].message.message_id,
            callback_this: event_this,
            callback_args: [event]
        });
        is(blog.length, 3);
        is(blog[2].direction, "send");
        deepEqual(jQluster.cloneViaJSON(blog[2].message), alog[2].message);
    }).then(null, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("selectAndListen - no target: the server should return an error message.", function() {
    setupAlice();
    alice_connection.clearLog();
    var event_deferred = $.Deferred();
    alice.selectAndListen({
        remote_id: "bob",
        eval_code: "$('#test_button')",
        method: 'dblclick',
        callback: function() {
            var args_array = jQluster.argsToArray(arguments);
            if(event_deferred.state() !== 'pending') {
                ok(false, "callback is called more than once");
                return;
            }
            event_deferred.resolve(this, args_array);
        }
    }).then(function() {
        ok(false, "the promise should not be resolved.");
    }, function(error) {
        ok(jQluster.defined(error));
        var alog = alice_connection.getLog();
        is(alog.length, 2);
        is(alog[0].direction, "send");
        is(alog[0].message.message_type, "select_and_listen");
        is(alog[0].message.from, "alice");
        is(alog[0].message.to, "bob");
        deepEqual(alog[0].message.body, {
            remote_id: "bob", eval_code: "$('#test_button')",
            method: "dblclick", options: []
        });
        is(alog[1].direction, "receive");
        is(alog[1].message.message_type, "select_and_listen_reply");
        is(alog[1].message.from, null);
        is(alog[1].message.to, "alice");
        is(alog[1].message.body.in_reply_to, alog[0].message.message_id);
        ok(jQluster.defined(alog[1].message.body.error));
    }).always(function() {
        start();
    });
});

asyncTest("selectAndListen - multiple targets", function() {
    setupAlice();
    setupBob();
    var bob2_set = createTransport("bob");
    var bob2_connection = bob2_set[0];
    var event_deferreds = [];
    var exp_event_num = 2;
    var next_event_index = 0;
    var i;
    for(i = 0 ; i < exp_event_num ; i++) {
        event_deferreds[i] = $.Deferred();
    }
    alice_connection.clearLog();
    bob_connection.clearLog();
    bob2_connection.clearLog();
    alice.selectAndListen({
        remote_id: "bob",
        eval_code: "$('#test_button')",
        method: "click",
        callback: function() {
            if(!event_deferreds[next_event_index] || event_deferreds[next_event_index].state() !== 'pending') {
                ok(false, "Unexpected event callback: next_event_index = " + next_event_index);
                return;
            }
            event_deferreds[next_event_index].resolve(this, jQluster.argsToArray(arguments));
            next_event_index++;
        }
    }).then(function() {
        var alog = alice_connection.getLog();
        is(alog.length, 3);
        is(alog[0].direction, "send");
        is(alog[0].message.message_type, "select_and_listen");
        is(alog[0].message.from, "alice");
        is(alog[0].message.to, "bob");
        deepEqual(alog[0].message.body, {
            remote_id: "bob", eval_code: "$('#test_button')", method: "click", options: []
        });
        $.each([1,2], function(i, log_index) {
            var label = "alog select_and_listen_reply" + log_index;
            is(alog[log_index].direction, "receive", label);
            is(alog[log_index].message.message_type, "select_and_listen_reply", label);
            is(alog[log_index].message.from, "bob", label);
            is(alog[log_index].message.to, "alice", label);
            deepEqual(alog[log_index].message.body, { error: null, result: "OK", in_reply_to: alog[0].message.message_id }, label);
        });
        $('#test_button').trigger('click');
        return $.when.apply($, event_deferreds);
    }).then(function(result1, result2) {
        var this1 = result1[0];
        var args1 = result1[1];
        var this2 = result2[0];
        var args2 = result2[1];
        var alog = alice_connection.getLog();
        deepEqual(this1, {
            remote_type: "xpath", remote_id: "bob",
            remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
        });
        ok(jQluster.defined(args1));
        deepEqual(this2, this1);
        ok(jQluster.defined(args2));
        is(alog.length, 5);
        is(alog[3].direction, "receive");
        is(alog[3].message.message_type, "signal");
        is(alog[3].message.from, "bob");
        is(alog[3].message.to, "alice");
        is(alog[3].message.body.error, null);
        is(alog[3].message.body.in_reply_to, alog[0].message.message_id);
        deepEqual(alog[3].message.body.callback_this, this1);
        is(alog[4].direction, "receive");
        is(alog[4].message.message_type, "signal");
        is(alog[4].message.from, "bob");
        is(alog[4].message.to, "alice");
        is(alog[4].message.body.error, null);
        is(alog[4].message.body.in_reply_to, alog[0].message.message_id);
        deepEqual(alog[4].message.body.callback_this, this1);
    }).then(null, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("selectAndListen - event delegation", function() {
    setupAlice();
    setupBob();
    var event_deferred = $.Deferred();
    alice.selectAndListen({
        remote_id: "bob",
        eval_code: "$('#test')",
        method: "on",
        options: ["click", "li"],
        callback: function() {
            if(event_deferred.state() !== 'pending') {
                ok(false, "unexpected event");
                return;
            }
            event_deferred.resolve(this, jQluster.argsToArray(arguments));
        }
    }).then(function() {
        is(event_deferred.state(), "pending");
        $('#test_button').trigger("click");
        return delay(0.001);
    }).then(function() {
        is(event_deferred.state(), "pending");
        $('#test').find('li').first().trigger('click');
        return event_deferred.promise();
    }).then(function(callback_this, callback_args) {
        deepEqual(callback_this, {
            remote_type: "xpath", remote_id: "bob", remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/ul[1]/li[1]"
        });
        ok(jQluster.defined(callback_args));
        
        event_deferred = $.Deferred();
        $('#test li.two').trigger('click');
        return event_deferred.promise();
    }).then(function(callback_this, callback_args) {
        deepEqual(callback_this, {
            remote_type: "xpath", remote_id: "bob", remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/ul[1]/li[2]"
        });
        ok(jQluster.defined(callback_args));
    }).then(null, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("selectAndListen - multiple listen calls to a single remote DOM, remote off() method to remove the listeners", function() {
    setupAlice();
    setupBob();
    var event_deferreds;
    var next_deferred_index;
    var request_base = {
        remote_id: "bob",
        eval_code: "$('#test').find('input#test_button')",
        method: "on",
        options: ["click"],
    };
    var initDeferreds = function(num) {
        var i;
        event_deferreds = [];
        for(i = 0 ; i < num ; i++) {
            event_deferreds.push($.Deferred());
        }
        next_deferred_index = 0;
    };
    var createCallback = function(label) {
        return function() {
            var d = event_deferreds[next_deferred_index];
            if(!jQluster.defined(d) || d.state() !== "pending") {
                ok(false, "unexpected callback");
                return;
            }
            next_deferred_index++;
            d.resolve(label, this, jQluster.argsToArray(arguments));
        }
    };
    var waitDeferreds = function() {
        return $.when.apply($, event_deferreds);
    };
    initDeferreds(1);
    alice.selectAndListen($.extend({}, request_base, {callback: createCallback("callback1")})).then(function() {
        is(event_deferreds[0].state(), "pending");
        $('#test_button').trigger('click');
        return waitDeferreds();
    }).then(function(callback_type, callback_this, callback_args) {
        is(callback_type, "callback1");
        deepEqual(callback_this, {
            remote_type: "xpath", remote_id: "bob",
            remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
        });
        ok(jQluster.defined(callback_args));

        initDeferreds(2);
        return alice.selectAndListen($.extend({}, request_base, {callback: createCallback("callback2")}));
    }).then(function() {
        is(event_deferreds[0].state(), "pending");
        is(event_deferreds[1].state(), "pending");
        $('#test_button').trigger('click');
        return waitDeferreds();
    }).then(function(result1, result2) {
        is(result1[0], "callback1", "callback1 fired");
        deepEqual(result1[1], {
            remote_type: "xpath", remote_id: "bob",
            remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
        });
        ok(jQluster.defined(result1[2]));
        is(result2[0], "callback2", "callback2 fired");
        deepEqual(result2[1], {
            remote_type: "xpath", remote_id: "bob",
            remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
        });
        ok(jQluster.defined(result2[2]));

        initDeferreds(0);
        return alice.selectAndGet({
            remote_id: "bob",
            eval_code: "$('#test_button').off('click')"
        });
    }).then(function() {
        $('#test_button').trigger('click');
        return delay(0.001);
    }).then(function() {
        ok(true, 'If there is no "unexpected callback" error, the callback is removed as expected.');
    }).then(null, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("selectAndListen - remote each() method", function() {
    setupAlice();
    setupBob();
    var each_results = [];
    alice.selectAndListen({
        remote_id: "bob",
        eval_code: "$('#test').find('li')",
        method: 'each',
        callback: function() {
            each_results.push({callback_this: this,
                               callback_args: jQluster.argsToArray(arguments)});
        }
    }).then(function() {
        return delay(0.001);
    }).then(function() {
        var i;
        var exp_pointer;
        is(each_results.length, 3, "callbacks called 3 times");
        for(i = 0 ; i < each_results.length ; i++) {
            exp_pointer = {
                remote_type: "xpath", remote_id: "bob",
                remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/ul[1]/li["+(i+1)+"]"
            };
            deepEqual(each_results[i].callback_this, exp_pointer, "results "+i+", callback_this");
            deepEqual(each_results[i].callback_args, [i, exp_pointer], "results "+i+", callback_args");
        }
        return alice.selectAndGet({
            remote_id: "bob",
            eval_code: '$(document).xpath("'+ each_results[1].callback_this.remote_xpath +'").attr("class")',
        });
    }).then(function(result) {
        is(result, "two", "selectAndGet with xpath OK");
    }).then(null, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

// TODO: erroneous cases, like syntax error in eval_code (not necessary in prototype phase)

////////////////////////////////////////////////////////////////////////
module("jQluster.RemoteSelector", {
    setup: setupAll,
    teardown: teardownTest,
});

test("constructor: eval_code", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob",
        eval_code: "$('#test').children('.hoge')"
    });
    is(remote._getEvalCode(), "$('#test').children('.hoge')");
});

test("constructor: selector", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob",
        selector: '#test .hoge'
    });
    is(remote._getEvalCode(), '$("#test .hoge")');
});

test("constructor: xpath", function() {
   var remote = new jQluster.RemoteSelector({
       transport: alice, remote_id: "bob",
       xpath: "//html[1]/body[1]/div[@id='#test']"
   }) ;
    is(remote._getEvalCode(), "$(document).xpath(\"//html[1]/body[1]/div[@id='#test']\")");
});

////////////////////////////////////////////////////////////////////////
module("jQluster.RemoteSelector - getter", {setup: setupAll, teardown: teardownTest});

$.each([
    {method: "attr", selector: "#test_button", args: ["type"], exp: "button"},
    {method: "hasClass", selector: "#test_button", args: ["hoge-class"], exp: false},
    {method: "val", selector: "#test_button", args: [], exp: "Test Button"},
    {method: "css", selector: "#sized-box", args: ["background-color"], exp: "rgb(255, 0, 0)"},
    {method: "height", selector: "#sized-box", args: [], exp: 50},
    {method: "innerHeight", selector: "#sized-box", args: [], exp: 60},
    {method: "innerWidth", selector: "#sized-box", args: [], exp: 210},
    {method: "outerHeight", selector: "#sized-box", args: [true], exp: 70},
    {method: "outerWidth", selector: "#sized-box", args: [false], exp: 210},
    {method: "width", selector: "#sized-box", args: [], exp: 200},
    {method: "data", selector: "#with-data", args: ["some-data"], exp: 100},
    {method: "text", selector: "#test li.two", args: [], exp: "2"},
    {method: "index", selector: "#test li.two", args: [], exp: 1},
    {method: "index", selector: "#test li.two", args: ["#test li.two"], exp: 0},
    {method: "size", selector: "#test li", args: [], exp: 3},
], function(i, testcase) {
    asyncTest(testcase.method + "()", function() {
        var remote = new jQluster.RemoteSelector({
            transport: alice, remote_id: "bob",
            selector: testcase.selector
        });
        remote[testcase.method].apply(remote, testcase.args).then(function(got_value) {
            deepEqual(got_value, testcase.exp);
        }, function(error) {
            ok(false, "error: " + error);
        }).always(function() {
            start();
        });
    });
});

asyncTest("promise() with animation", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob",
        selector: "#test li.two"
    });
    remote.fadeOut(20);
    var promise = remote.promise("fx", {type: "my_target"});
    is(promise.type, "my_target");
    promise.then(function(arg) {
        is(arg, remote, "arg of the promise is the remote object itself");
        is(this, remote, "this in the promise handler is the remote object itself");
        is($("#test li.two").css("display"), "none", "fadeOut animation is complete");
    }, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

////////////////////////////////////////////////////////////////////////
module("jQluster.RemoteSelector - selection", {
    setup: setupAll,
    teardown: teardownTest,
});


$.each([
    {method: "children", args: [".hoge"], exp: '$("#top").children(".hoge")'},
    {method: "closest", args: [".hoge"], exp: '$("#top").closest(".hoge")'},
    {method: "contents", args: [], exp: '$("#top").contents()'},
    {method: "eq", args: [4], exp: '$("#top").eq(4)'},
    {method: "end", args: [], exp: '$("#top").end()'},
    {method: "filter", args: [".hoge"], exp: '$("#top").filter(".hoge")'},
    {method: "find", args: [".hoge"], exp: '$("#top").find(".hoge")'},
    {method: "first", args: [], exp: '$("#top").first()'},
    {method: "has", args: [".hoge"], exp: '$("#top").has(".hoge")'},
    {method: "is", args: [".hoge"], exp: '$("#top").is(".hoge")'},
    {method: "last", args: [], exp: '$("#top").last()'},
    {method: "next", args: [".hoge"], exp: '$("#top").next(".hoge")'},
    {method: "nextAll", args: [".hoge"], exp: '$("#top").nextAll(".hoge")'},
    {method: "nextUntil", args: [".hoge", ".foobar"], exp: '$("#top").nextUntil(".hoge",".foobar")'},
    {method: "not", args: [".hoge"], exp: '$("#top").not(".hoge")'},
    {method: "offsetParent", args: [], exp: '$("#top").offsetParent()'},
    {method: "parent", args: [".hoge"], exp: '$("#top").parent(".hoge")'},
    {method: "parents", args: [".hoge"], exp: '$("#top").parents(".hoge")'},
    {method: "parentsUntil", args: [".hoge", ".foobar"], exp: '$("#top").parentsUntil(".hoge",".foobar")'},
    {method: "prev", args: [".hoge"], exp: '$("#top").prev(".hoge")'},
    {method: "prevAll", args: [], exp: '$("#top").prevAll()'},
    {method: "prevUntil", args: [".hoge", ".foobar"], exp: '$("#top").prevUntil(".hoge",".foobar")'},
    {method: "siblings", args: [".hoge"], exp: '$("#top").siblings(".hoge")'},
    {method: "slice", args: [4, 9], exp: '$("#top").slice(4,9)'}
], function(i, testcase) {
    test(testcase.method + "()", function() {
        var remote = new jQluster.RemoteSelector({
            transport: alice, remote_id: "bob",
            selector: '#top'
        });
        is(remote[testcase.method].apply(remote, testcase.args)._getEvalCode(), testcase.exp);
    });
});

test("chained selections", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: '#top'
    });
    is(
        remote.find(".hoge").eq(10).parentsUntil(".foo", ".bar")._getEvalCode(),
        '$("#top").find(".hoge").eq(10).parentsUntil(".foo",".bar")'
    );
});


////////////////////////////////////////////////////////////////////////
module("jQluster.RemoteSelector - callbacks", {
    setup: setupAll,
    teardown: teardownTest,
});

asyncTest("on() - direct", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: "#test"
    });
    var timelimit = setTimeLimit();
    var button_remote = remote.find("#test_button");
    var on_ret = button_remote.on("click", function(event) {
        clearTimeout(timelimit);
        is(event.type, "click");
        deepEqual(this, {
            remote_type: "xpath", remote_id: "bob",
            remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
        });
        start();
    });
    is(on_ret, button_remote);
    $('#test_button').trigger('click');
});

asyncTest("on() - delegated", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: "#test"
    });
    var timelimit = setTimeLimit();
    var on_ret = remote.on("click", "input", function(event) {
        clearTimeout(timelimit);
        is(event.type, "click");
        deepEqual(this, {
            remote_type: "xpath", remote_id: "bob",
            remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
        });
        start();
    });
    is(on_ret, remote);
    $('#test_button').trigger('click');
});

asyncTest("on() - with data", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: "#test_button"
    });
    var timelimit = setTimeLimit();
    var on_ret = remote.on("click", null, {some: "data"}, function(event) {
        clearTimeout(timelimit);
        is(event.type, "click");
        deepEqual(event.data, {some: "data"});
        deepEqual(this, {
            remote_type: "xpath", remote_id: "bob",
            remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
        });
        start();
    });
    is(on_ret, remote);
    $('#test_button').trigger('click');
});

asyncTest("on() - Object as events", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: "#test_button"
    });
    var timelimit = setTimeLimit();
    var events = {click: $.Deferred(), mouseenter: $.Deferred()};
    var exp_remote_dom = {
        remote_type: "xpath", remote_id: "bob",
        remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/input[@id='test_button']"
    };
    var on_ret = remote.on({
        click: function(event) {
            is(event.type, "click");
            deepEqual(this, exp_remote_dom);
            events.click.resolve();
        },
        mouseenter: function(event) {
            is(event.type, "mouseenter");
            deepEqual(this, exp_remote_dom);
            events.mouseenter.resolve();
        }
    });
    is(on_ret, remote);
    $.when(events.click.promise(), events.mouseenter.promise()).then(null, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        clearTimeout(timelimit);
        start();
    });
    $("#test_button").trigger("click");
    $("#test_button").trigger("mouseenter");
});

asyncTest("each() - full loop", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: "#test li"
    });
    var results = [];
    var each_ret = remote.each(function(i, elem) {
        results.push([this, i, elem]);
    });
    is(each_ret, remote, "return value of each()");
    var exp_elems = [
        {remote_type: "xpath", remote_id: "bob",
         remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/ul[1]/li[1]"},
        {remote_type: "xpath", remote_id: "bob",
         remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/ul[1]/li[2]"},
        {remote_type: "xpath", remote_id: "bob",
         remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/ul[1]/li[3]"},
    ];
    delay(0.05).then(function() {
        deepEqual(
            results,
            [[exp_elems[0], 0, exp_elems[0]],
             [exp_elems[1], 1, exp_elems[1]],
             [exp_elems[2], 2, exp_elems[2]]]
        );
    }, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("each() - breaking loop", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: "#test li"
    });
    var results = [];
    var each_ret = remote.each(function(i, elem) {
        results.push([this, i, elem]);
        if(i === 1) {
            return false;
        }
    });
    is(each_ret, remote);
    var exp_elems = [
        {remote_type: "xpath", remote_id: "bob",
         remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/ul[1]/li[1]"},
        {remote_type: "xpath", remote_id: "bob",
         remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/ul[1]/li[2]"},
    ];
    delay(0.05).then(function() {
        deepEqual(
            results,
            [[exp_elems[0], 0, exp_elems[0]],
             [exp_elems[1], 1, exp_elems[1]]]
        );
    }, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});


////////////////////////////////////////////////////////////////////////
module("jQluster.RemoteSelector - setters", {
    setup: setupAll,
    teardown: teardownTest,
});

asyncTest("off() - only plain events calling convention is supported for now", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: "#test_button"
    });
    remote.on("click", function() {
        ok(false, "this callback must be cancelled");
    });
    var off_ret = remote.off("click");
    is(off_ret, remote);
    delay(0.05).then(function() {
        $("#test_button").trigger("click");
        return delay(0.05);
    }).then(null, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});

asyncTest("append()", function() {
    var remote = new jQluster.RemoteSelector({
        transport: alice, remote_id: "bob", selector: "#test .two"
    });
    var append_result = remote.append('<span class="appended">200</span>');
    is(append_result, remote);
    delay(0.05).then(function() {
        is($("#test .two .appended").text(), "200");
    }, function(error) {
        ok(false, "error: " + error);
    }).always(function() {
        start();
    });
});


////////////////////////////////////////////////////////////////////////
module("jQluster.RemoteSelector - effects", {
    setup: setupAll,
    teardown: teardownTest,
});

(function() {
    var ANIMATION_DURATION = 20;
    var WAIT_TIME = 40;
    $.each([
        {label: "animate() - simple form", target_box_id: "hidden-box", method: "animate", args: [{opacity: 1}, ANIMATION_DURATION],
         exp_style: "opacity", exp_value: "1" },
        {label: "fadeIn()", target_box_id: "hidden-box", method: "fadeIn", args: [ANIMATION_DURATION],
         exp_style: "display", exp_value: "block" },
        {label: "fadeTo()", target_box_id: "visible-box", method: "fadeTo", args: [ANIMATION_DURATION, 0.7],
         exp_style: "opacity", exp_value: "0.7"},
        {label: "fadeOut()", target_box_id: "visible-box", method: "fadeOut", args: [ANIMATION_DURATION],
         exp_style: "display", exp_value: "none"},
        {label: "hide()", target_box_id: "visible-box", method: "hide", args: [],
         exp_style: "display", exp_value: "none"},
        {label: "show()", target_box_id: "hidden-box", method: "show", args: [],
         exp_style: "display", exp_value: "block"}
    ], function(i, testcase) {
        asyncTest(testcase.label + " with callback", function() {
            var remote = new jQluster.RemoteSelector({
                transport: alice, remote_id: "bob", selector: "#" + testcase.target_box_id
            });
            var timelimit = setTimeLimit();
            var ret_val = remote[testcase.method].apply(remote, testcase.args.concat([function() {
                var remote = this;
                clearTimeout(timelimit);
                deepEqual(remote, {remote_type: "xpath", remote_id: "bob",
                                   remote_xpath: "//html[1]/body[1]/div[@id='qunit-fixture']/div[@id='test']/div[@id='"
                                   + testcase.target_box_id +"']"}, "remote DOM pointer OK");
                is($("#" + testcase.target_box_id).css(testcase.exp_style), testcase.exp_value, "css result OK");
                start();
            }]));
            is(ret_val, remote, "ret_val from " + testcase.method + "() is the invocant.");
        });
        
        asyncTest(testcase.label + " without callback", function() {
            var remote = new jQluster.RemoteSelector({
                transport: alice, remote_id: "bob", selector: "#" + testcase.target_box_id
            });
            var ret_val = remote[testcase.method].apply(remote, testcase.args);
            is(ret_val, remote, "rev_val from " + testcase.method + "() is the invocant");
            setTimeout(function() {
                is($("#" + testcase.target_box_id).css(testcase.exp_style), testcase.exp_value, "css result OK");
                start();
            }, WAIT_TIME);
        });
    });
})();

// TODO: Implement .filter(func) and .map(func). Not so trivial.

</script>
</body>
</html>
